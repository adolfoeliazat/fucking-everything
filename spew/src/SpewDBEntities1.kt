package vgrechka.spew

import vgrechka.*
import java.io.File
import java.time.LocalDateTime
import java.util.*

class spewDBEntities {
    init {
        val file = File(BigPile.fuckingEverythingRoot + "/spew-gen-tests/gen/generated--for-GeneratedEntitiesForAmazingWordsTest.kt")
        val code = StringBuilder()
        val shit = Shitter(code, indent = 0)

        shitHeaderComment(shit, "vgrechka.spewgentests")
        shit.line("// Fuck you    ${Date()}")

        backUpAndWrite(file, code.toString())
    }

    fun shitHeaderComment(shit: Shitter, packageName: String) {
        shit.line("""
                /*
                 * (C) Copyright 2017 Vladimir Grechka
                 *
                 * YOU DON'T MESS AROUND WITH THIS SHIT, IT WAS GENERATED BY A TOOL SMARTER THAN YOU
                 */

                package $packageName

                import vgrechka.*
                import kotlin.reflect.KClass
            """)
        shit.line("")
    }

    private fun backUpAndWrite(file: File, newCode: String) {
        backUpIfExists(file)
        file.writeText(newCode)
        clog("Written ${file.path}")
    }


    private fun backUpIfExists(file: File) {
        if (!file.exists()) return

        check(file.path.replace("\\", "/").startsWith(BigPile.fuckingEverythingRoot + "/")) {"9911cfc6-6435-4a54-aa74-ad492162181a"}

        val stamp = LocalDateTime.now().format(PG_LOCAL_DATE_TIME).replace(Regex("[ :\\.]"), "-")
        val outPath = (
            BigPile.spewBak + "/" +
                file.path
                    .substring(BigPile.fuckingEverythingRoot.length)
                    .replace("\\", "/")
                    .replace(Regex("^/"), "")
                    .replace("/", "--")
                + "----$stamp"
            )

        // clog("Backing up: $outPath")
        File(outPath).writeText(file.readText())
    }
}

class Shitter(val output: StringBuilder, val indent: Int) {
    fun line(src: String) {
        var s = dedent(src)
        s = reindent(indent, s)
        if (!s.endsWith("\n")) s += "\n"
        output += s
    }

    fun bigSection(title: String) {
        line("")
        line("// ==================================================================")
        line("// $title")
        line("// ==================================================================")
        line("")
    }

    fun smallSection(title: String) {
        line("// ------------------------------------------------------------------")
        line("// $title")
        line("// ------------------------------------------------------------------")
        line("")
    }
}


fun dedent(it: String): String {
    var lines = it.split(Regex("\\r?\\n"))
    if (lines.size > 0 && lines[0].isBlank()) {
        lines = lines.drop(1)
    }
    if (lines.size > 0 && lines.last().isBlank()) {
        lines = lines.dropLast(1)
    }

    var minIndent = 9999 // TODO:vgrechka Platform-specific max integer (for JS: Number.MAX_SAFE_INTEGER)
    for (line in lines) {
        if (!line.isBlank()) {
            val lineIndent = line.length - line.trimStart().length
            if (lineIndent < minIndent) {
                minIndent = lineIndent
            }
        }
    }

    return lines.map {line ->
        if (line.trim().isBlank()) ""
        else line.substring(minIndent)
    }.joinToString("\n")
}

fun reindent(newIndent: Int, it: String): String {
    return dedent(it).split("\n").joinToString("\n") {" ".repeat(newIndent) + it}
}


